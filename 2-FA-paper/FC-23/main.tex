% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[runningheads]{llncs}
%
\usepackage[T1]{fontenc}
\usepackage{multicol}
\usepackage{multirow}
\usepackage[table]{xcolor}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{color}
\usepackage{prettyref}
\newrefformat{fig}{Figure~\ref{#1}}
\newrefformat{tab}{Table~\ref{#1}}
\usepackage{booktabs}
\usepackage{xspace}
%\usepackage[disable]{todonotes}
\usepackage{todonotes}
\raggedbottom% to remove huge space
\usepackage{url}
\def\doubleunderline#1{\underline{\underline{#1}}}



%%%%%%%%
\usepackage{framed}
\usepackage{esvect}
\usepackage{tikz}
\usepackage{blkarray}% http://ctan.org/pkg/blkarra
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{bm}
\usepackage{adjustbox}
\usepackage{boxedminipage}
\usepackage{blindtext}
\usepackage{multicol}
%%%%%%%%%
\usepackage{pgfplots, pgfplotstable}

\usepackage{hyperref}
\usepackage{float}
\usepackage{boxedminipage}
\usepackage{enumitem}
%\usepackage{makeidx}  % allows for indexgeneration
%\usepackage{amsfonts,amsmath,amssymb,graphicx,setspace,tipx}
\usepackage{amsmath}
\usepackage{float}
\usepackage[ruled,linesnumbered]{algorithm2e}
\usepackage{subfig}
\usepackage{graphicx}
\usepackage{framed}
\usepackage{esvect}
\usepackage{tikz}
\usepackage{latexsym}

%\usepackage{pgfplots}
\usepackage{pgfplots, pgfplotstable}
\usepackage{blkarray}% http://ctan.org/pkg/blkarra
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{bm}
\usepackage{adjustbox}
\usepackage{blindtext}
\usepackage{multicol}
\usepackage{prettyref}
\usepackage{multirow}
\usepackage{adjustbox}
\usepackage{blindtext}
\usepackage{multicol}
\usepackage{tablefootnote}
\usepackage{colortbl}
\usepackage[skins]{tcolorbox}
%%%%%%%%%%%
\newtcolorbox{mybox}[2][]{%
  attach boxed title to top center
               = {yshift=-11pt},
               %width=85mm,%
                  %height=52mm,
  %colback      = black,
  colframe     =black,
  %fonttitle    = \bfseries,
  colbacktitle = black,
  title        = #2,#1,
  enhanced,
}




% Add a period to the end of an abbreviation unless there's one
% already, then \xspace.
\makeatletter
\DeclareRobustCommand\onedot{\futurelet\@let@token\@onedot}
\def\@onedot{\ifx\@let@token.\else.\null\fi\xspace}

\def\eg{\emph{e.g}\onedot} \def\Eg{\emph{E.g}\onedot}
\def\ie{\emph{i.e}\onedot} \def\Ie{\emph{I.e}\onedot}
\def\cf{\emph{c.f}\onedot} \def\Cf{\emph{C.f}\onedot}
\def\etc{\emph{etc}\onedot} \def\vs{\emph{vs}\onedot}
\def\wrt{w.r.t\onedot} \def\dof{d.o.f\onedot}
\def\etal{\emph{et al}\onedot}
\makeatother

%\usepackage{amsmath}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
\usepackage{hyperref}
\newcommand{\sss}{\scriptscriptstyle}
\renewcommand\UrlFont{\color{blue}\rmfamily}
\usepackage[primitives,operators,sets,keys,ff,lambda,adversary]{cryptocode}
\newcommand{\nonce}{\ensuremath{{N}}}
\newcommand{\keyt}{\ensuremath{{kt}}}
\newcommand{\counter}{\ensuremath{{ct}}}
\newcommand{\pin}{\ensuremath{\mathsf{PIN}}}
\newcommand{\salt}{\ensuremath{{sa}}}
\newcommand{\trans}{\ensuremath{{t}}}
\newcommand{\extract}{\ensuremath{\mathsf{Extract}}}
\renewcommand{\verifier}{\ensuremath{{v}}}
\renewcommand{\state}{\ensuremath{{st}}}
\newcommand{\update}{\ensuremath{\mathsf{Update}}}
\newcommand{\VC}[1]{\ensuremath{#1^{\sss C}}}
\newcommand{\VS}[1]{\ensuremath{#1^{\sss S}}}
\newcommand{\VM}[1]{\ensuremath{#1^{\sss M}}}
\newcommand{\parse}{\ensuremath{\mathsf{Parse}}}
\newcommand{\tmp}{\ensuremath{{tmp}}}
\newcommand{\iif}{\ensuremath{\text{If\ }}}
\newcommand{\ssample}{\stackrel{\sss\$}\leftarrow}
\newcommand{\forEach}{\ensuremath{\text{For each\ }}}
\newcommand{\tto}{\ensuremath{\text{to\ }}}

\newcommand{\execute}{$\mathtt{Execute}$}
\newcommand{\send}{$\mathtt{Send}$}
\newcommand{\test}{$\mathtt{Test}$}
\newcommand{\reveal}{$\mathtt{Reveal}$}
\newcommand{\corrupt}{$\mathtt{Corrupt}$}
\newcommand{\A}{\mathcal{A}}
\newcommand{\seckey}{\ensuremath{\mathit{sk}}}
\newcommand{\SID}{\ensuremath{\mathit{SID}}}
\newcommand{\PID}{\ensuremath{\mathit{PID}}}

\begin{document}

\title{A Forward-secure Efficient\\ Two-factor Authentication Protocol}

\author{}
\institute{}

\maketitle  

\begin{abstract}
Two-factor authentication (2FA) schemes that rely on a combination of knowledge factors (e.g., PIN) and device possession have gained popularity. Some of these schemes remain secure even against strong adversaries that (a) observe the traffic between a client and server, and (b) have physical access to the client’s device, or its PIN, or breach the server.  However, these solutions have several shortcomings; namely, they (i) require a client to remember \emph{multiple} secret values to prove its identity, (ii) involve \emph{several modular exponentiations}, and (iii) are in the \emph{non-standard} random oracle model. In this work, we present a 2FA protocol that resists such a strong adversary while addressing the above shortcomings. Our protocol requires a client to remember only a single secret value/PIN, does not involve any modular exponentiations, and is in a standard model. It is the first one that offers these features without using trusted chipsets. This protocol also imposes up to $40\%$ lower communication overhead than the state-of-the-art solutions do. \todo{Note application to financial cryptography}

\end{abstract}



\input{introduction}

\input{short-related-work}

\input{preliminaries}

\input{model}


\vspace{-4.6mm}

\section{The Protocol}\label{sec::the-protocol}
\vspace{-3mm}

In this section, we present an efficient 2FA protocol that remains secure even if an adversary (a) observes the traffic between a client and server, and (b) has access to the client’s device, or its PIN, or breaches the server. To design a protocol that can offer the above features, we rely on a novel combination of the following two approaches. First, we require the client's  PIN verification to take place only on the server.\todo{Is this too repetitive?} This allows us to separate the location where the PIN's secret key (used to generate the PIN's authenticator) is stored from the location where the authenticator is stored. This approach ensures that even if either location is breached, then the adversary would not have sufficient information to retrieve the PIN even through brute-forcing all possible PINs. Our observation is that even in this setting, the device can perform a basic check to detect the client's mistake without having to permanently store the (representation of the) PIN; for instance, this can be done by asking the client to type in the PIN twice and checking if the two entries match with each other.\todo{Move to usability discussion}



Second, we (a) require every sensitive message exchanged between the server and client to be encrypted using key-evolving symmetric-key encryption (i.e., a combination of forward-secure pseudorandom bit generator and authenticated encryption) and (b) require the used keys, of key-evolving symmetric-key encryption, to be discarded immediately after their use. This approach ensures the secrecy of the communication between the parties and ensures that if the device or server is compromised, the adversary cannot learn the past communication to learn the PIN, with the assistance of the information it extracts from the breached location. 



Our protocol consists of three main phases; namely, (i) a setup phase, performed once when the authentication device is manufactured, (ii) an enrolment phase for setting or changing a client's PIN, and (iii) an authentication phase in which the actual authentication is performed. As we already stated, each party has a unique (public) ID. In the protocol, we assume the parties include their IDs in their outgoing messages.  Similar to other (two-factor) authentication schemes, we assume the server maintains a local threshold, and if the number of incorrect responses from a client within a fixed time exceeds the threshold, then the client and its device will be locked out. Such a check is implicit in the protocol's description. In the remaining of this section, we describe each phase. 


 \vspace{-4mm}

\subsection{Setup Phase}
\label{sec:setup}

\vspace{-1mm}


To bootstrap the protocol, in the setup phase, we require that the client
and server share \emph{initial} randomly generated key $k$ for AE and key $\state_{\sss 0}$ for  FS-PRG.
The counter for the FS-PRG state is set to $0$ on both sides. 
These values could be securely loaded into the device at the time of
manufacture or can be sent (via a secure channel) to the client who can use the device camera to scan and store them in the device. In this phase, the device generates and locally stores a random secret key $\VC{\salt}$ for \prf.  \prettyref{fig:setup} presents the setup in detail. 



\begin{figure}[!htbp]
\begin{center}
    \begin{tcolorbox}[enhanced,width=4.75in, height=61mm, left=1mm,top=-4mm,
    drop fuzzy shadow southwest,
    colframe=black,colback=white]
%{\small{
 \centering
 \procedure{}{%
 \hspace{8mm}\underline{\textbf{Client}} \< \<\hspace{4mm} \underline{\textbf{Server}} \\
  % \noindent\rule{4.6in}{1pt}
 \pcln \< \<\hspace{4mm} k \ssample \mathsf{Gen}(\secparam) \\
 \pcln \< \<\hspace{4mm} \state_{\sss 0} \ssample \mathsf{FS\text{-}RPG}.\kgen(\secparam) \\
  \pcln \< \<\hspace{4mm} C_{\sss ID} \gets \mathsf{IDGen}(\secparam) \pclb
  %
 \< \sendmessageleft*{(\text{$k$,  $\state_{\sss 0}$, $C_{\sss ID}$)}} \< \\
 %
 \pcln \text{set  $\VC{k}$ to $k$} \< \<\hspace{4mm} \text{set $\VS{k}$ to $k$}\\
 %
 \pcln \text{set $\VC{\state}$ to  $\state_{\sss 0}$} \< \<\hspace{4mm} \text{set  $\VS{\state}$ to $\state_{\sss 0}$}\\
 %
  \pcln \text{store$(C_{\sss ID}, \VC{k}, \VC{\state})$} \< \<\hspace{4mm} \text{store $(C_{\sss ID}, \VS{k}, \VS{\state})$}\\
  %
 \pcln \VC{\counter} \gets 0 \< \<\hspace{4mm} \VS{\counter} \gets 0 \\
 %
 \pcln \VC{\salt} \ssample \{0,1\}^{\sss \psi} \< \<\hspace{4mm} \\
% \pcln \VC{\salt} \ssample \kgen(\secparam) \< \< \\
 }
%}}
\end{tcolorbox}
\end{center}
\vspace{-4.5mm}
    \caption{Setup phase.}
    \label{fig:setup}
\end{figure}

\vspace{-4mm}
\subsection{Enrolment Phase}
\label{sec:enrollment}



The goal of the enrolment phase is to set the client's PIN, without providing the  
 server with sufficient information to discover this PIN. 
% 
% The server allows this phase to take place only over a channel through which the client has already proven their identity. 
 %
  At the end of this phase, the server will have stored the verifier $\verifier$ corresponding to the client's selected PIN.
The steps involved in this phase are shown in \prettyref{fig:enrollment} in detail.  




%%%%%%%%%%%%%%%%%
\begin{figure}[!htb]
\setlength{\fboxsep}{1pt}
\begin{center}
    \    \begin{tcolorbox}[enhanced,width=4.75in, height=157mm, left=1mm,top=-.5mm,
    drop fuzzy shadow southwest,
    colframe=black,colback=white]
%{\small{
 \centering
 \procedure{}{%
  \hspace{8mm}\underline{\textbf{Client}} \< \hspace{12ex} \<\hspace{4mm} \underline{\textbf{Server}} \\
 %%%%%%
 %
\pclb
 %
 \sendmessagerightx[5cm]{6}{(C_{\sss ID},  \text{enrolment})} \\% encrypt
 %%%%%% Server
 \pcln \< \<\hspace{2.6mm} \VS{\counter} \gets \VS{\counter} + 1  \\
 \pcln \< \<\hspace{2.6mm} \VS{\keyt_{\sss 1}}, \VS{\state} \gets \update(\VS{\state}, 1)\\% update
 %
% \pcln \< \< key_1= H(\VS{\keyt_1}||
 %
 \pcln \< \<\hspace{2.6mm} \VS{\nonce} \stackrel{\$}\leftarrow \bin^{\sss\secpar}  \\
 %
 \pcln \< \<\hspace{2.6mm} p= \VS{\nonce}|| \VS{\counter}\\ % server-- set plaintext
 %
 \pcln \< \<\hspace{2.6mm} {(M,t) \gets \enc_{\sss\VS{k}}(p) } \pclb
 %
 \sendmessageleftx[7cm]{6}{(M,t) } \\% server--encrypt
 %%%%% Client
 %
  \pcln (p,b) \gets \mathsf{Dec}_{\sss\VC{k}}(M,t) \< \< \\% client-- decrypt
  %
  \pcln \iif b\neq 1,    \text{\ then\ go\ to\ } \ref{enroll:fail} \\ % client-- verify tag
  %
   \pcln \text{Parse\ } p \text{\ which\ yields\ } \VM{\nonce}, \VM{\counter} \< \< \\ % client-- parse
  %
 \pcln\label{enroll:clinet-check-counter}  \iif \VM{\counter} \le \VC{\counter}, \text{\ then\ go\ to\ } \ref{enroll:fail} \\ %client check counter
 %
 %\pcln  \VC{\state} \gets  \tmp_{\VC{\state}}\\% client set state
 \pcln \text{Request \VC{\pin} from client} \< \< \\
 %
 \pcln \VC{\verifier} \gets \prf_{\sss\VC{\salt}}(\VC{\pin}) \< \< \\
 %
 %%%%%%%%%%%%%%
 \pcln d=  \VM{\counter}-\VC{\counter} \< \< \\
 %
%  \pcln \forEach i \in[1,d]: \< \< \\
  %
   \pcln   \VC{\counter} \gets \VC{\counter} + d\< \< \\
    \pcln \VC{\keyt_{\sss 1}},  \VC{\state} \gets \update(\VC{\state}, d) \< \< \\ % update
 %%%%%%%%
 %
 %\pcln \VC{\keyt_{\sss 1}} \gets k \< \< \\ % set the key
 %
 \pcln p'=  \VM{\nonce} || \VC{\verifier}\< \< \\ %client--set plaintext
 %
 \pcln (M',t') \gets \enc_{\sss\VC{\keyt_{\sss 1}}}(p')\< \< \pclb
 %
 \sendmessagerightx[7cm]{6}{(M',t') } \\% encrypt
 %
  \pcln \label{enroll:fail} \text{Discard (\VC{\pin}, \VC{\verifier}, \VC{\keyt_{\sss 1}},  \VC{\nonce}})% \text{and\ abort} 
 %%%%%% Server
 \< \<\hspace{2.6mm} (p',b') \gets \mathsf{Dec}_{\sss\VS{\keyt_{\sss 1}}}(M',t') \< \< \\% server-- decrypt
  %
   \pcln\< \<\hspace{2.6mm} \iif b'\neq 1,    \text{\ then\ go\ to\ } \ref{enroll:fail} \\ % client-- verify tag
  %
 \pcln\< \<\hspace{2.6mm} \text{Parse\ } p' \text{\ yielding\ }  \VM{\nonce},  \VM{\verifier} \< \< \\
  %
 \pcln \< \<\hspace{2.6mm} \iif \VM{\nonce} \ne \VS{\nonce}, \text{then \ go\ to\ } \ref{enroll:fail-server-} \\
 %
 \pcln \< \<\hspace{2.6mm} \text{Store \VM{\verifier} as \VS{\verifier}} \\
 %
% \pcln \label{enroll:fail} \text{Discard \VC{\pin}, \VC{\verifier}, \VC{\keyt_{\sss 1}},  \VC{\nonce}} \text{and\ abort} 
 %
  \pcln \label{enroll:fail-server-} \< \<\hspace{2.6mm}  \text{Discard (\VS{\keyt_{\sss1}}, \VS{\nonce}}) \\ %\text{and\ abort} \\
 }
%}}
\end{tcolorbox}
\end{center}
\vspace{-4.5mm}
    \caption{Enrolment phase.}
    \label{fig:enrollment}
\end{figure}


We briefly explain how this phase works.  The server first updates the FS-PRG's state, which results in a new state and random value \VS{\keyt_{\sss 1}}; it also increments its counter by one. Then, the server generates a random challenge \VS{\nonce}. The server sends the enrolment challenge message which is a combination of the current counter and the challenge encrypted via the AE under the shared key $k$.
%
 On receiving this message, the client uses its device to scan the (QR) message it receives\todo{Either generalise from a QR code or mention this earlier}. The device decrypts the message using $k$ that was shared with the server during the setup phase.  If decryption succeeds, it  extracts the server's challenge and counter from the message.  If the device's local counter is greater than the counter it received from the server, it would be impossible for the device to recover the $\VS{\keyt_{\sss 1}}$ that the server will use, so the protocol must abort here. As we will discuss in Appendix \ref{sec:synchronisation}, this case would not occur, with a high probability. Next, the device requests the PIN from the client and ensures it is what the client intends, e.g., by requesting it twice and checking they match.



The device then generates a verifier $\VC{\verifier}$, by deriving a pseudorandom value from the PIN using $\prf$ and the random key $\VC{\salt}$ it generated in the setup phase.  After that, the device locally synchronises the FS-PRG's state with the server by updating the state until it matches the counter received from the server; this yields \VC{\keyt_{\sss 1}}. This synchronisation is possible because the check at line \ref{enroll:clinet-check-counter} has already assured that the device's state is behind the server's state by at least one step. After the update, \VC{\keyt_{\sss 1}} will equal \VS{\keyt_{\sss 1}} because the initial FS-PRG's state is the same (from the setup phase) and the two generators have been updated the same number of times. The client then encrypts the verifier and challenge under \VC{\keyt_{\sss 1}} and sends this to the server. 
 %
On receiving and validating this message, the server decrypts the message using \VS{\keyt{\sss 1}}, then extracts the challenge and verifier.
If the challenge does not match the one corresponding to the current protocol exchange, the protocol halts.
If the challenge does match, the server stores the verifier, $\VS{\verifier}$,  associated with the client's account.

Finally, the device discards the challenge, \VC{\keyt_{\sss 1}}, PIN, and \VC{\verifier} so that the PIN can no longer be recovered from the device. Note that the device can re-generate \VC{\verifier} using \VC{\salt} when the client types in its PIN again. The server also discards the challenge and \VC{\keyt{\sss 1}} as they are no longer needed. Following the successful completion of this protocol, the server will store the verifier corresponding to the client's selected PIN and both server and device will have synchronised their FS-PRG's state.

\vspace{-4mm}
\subsection{Authentication Phase}
\label{sec:authentication}

The goal of the authentication process is to give the server assurance that the device is currently present, the correct PIN has been entered, and the client has been shown the transaction that the server wishes to execute.\todo{mention transaction earlier} 
%


%%%%%%%%%%%%%%%%%%
\begin{figure}[!htbp]

\begin{center}
     \begin{tcolorbox}[enhanced,width=4.75in, height=194mm, left=1mm,top=-1mm,
    drop fuzzy shadow southwest,
    colframe=black,colback=white]
%{\small{
 \centering
 \procedure{}{%
  \hspace{8mm}\underline{\textbf{Client}} \< \hspace{0ex} \<\hspace{2.6mm} \underline{\textbf{Server}} \\
\pclb
 %
\sendmessagerightx[5cm]{6}{(C_{\sss ID}, \text{authentication}) } \\% encrypt
 %
 \pcln \< \<\hspace{2.6mm} \VS{\counter} \gets \VS{\counter} + 1 \\ % server-- increment counter
 %
 \pcln \< \<\hspace{2.6mm}  \VS{\keyt_{\sss 2}}, \VS{\state} \gets \update(\VS{\state}, 1)\\% server-- update
 %
  \pcln \< \<\hspace{2.6mm}  \tmp_{\sss\VS{\counter}} \gets \VS{\counter}, \ \VS{\counter} \gets \VS{\counter} + 1 \< \< \\
 %
% \pcln \< \< \VS{\counter} \gets \VS{\counter} + 1 \\ % server-- increment counter again
 %
 \pcln \< \< \hspace{2.6mm} \VS{\keyt_{\sss 3}}, \VS{\state} \gets \update(\VS{\state}, 1)\\% server-- update again
 %
 \pcln \< \<\hspace{2.6mm} \VS{\nonce} \stackrel{\$}\leftarrow \bin^{\sss \secpar}, \  p= \VS{\nonce} || \VS{\trans} \ \\  % server--pick a challenge
%
 \pcln \< \<\hspace{2.6mm} (\ddot M, \ddot t)\leftarrow \enc_{\sss\VS{\keyt_{\sss 2}}}(p)\\
 %
 \pcln \< \<\hspace{2.6mm} (\hat M, \hat t)\leftarrow \enc_{\sss\VS{k}}( \tmp_{\VS{\counter}})\pclb
 %
 \sendmessageleftx[7cm]{6}{(\ddot M, \ddot t), (\hat M, \hat t)} \\ % server-- encrypt
 %
 %%%%%  client
 %
   \pcln (\tmp_{\sss\VM{\counter}},b') \gets \mathsf{Dec}_{\sss\VC{k}}(\hat M, \hat t) \< \< \\% client-- decrypt
  %
  \pcln \iif b'\neq 1,    \text{\ go\ to\ } \ref{auth:fail} \\ % client-- verify tag
   %
    \pcln \iif \tmp_{\sss\VM{\counter}} \le \VC{\counter}, \text{\ go\ to\ } \ref{auth:fail} \< \< \\
   %
    %%%%%%%%%%%%%%
 \pcln d=  \tmp_{\sss\VM{\counter}}-\VC{\counter},\  \VC{\counter} \gets \VC{\counter} + d+1\  \< \< \\
 %
  %\pcln \forEach i \in[1,d]: \< \< \\
  % \pcln    \VC{\counter} \gets \VC{\counter} + d+1\< \< \\
    \pcln \VC{\keyt_{\sss 2}},  \VC{\state} \gets \update(\VC{\state}, d) \< \< \\ % update
 %%%%%%%%
   %
    %\pcln \VC{\keyt_{\sss 2}} \gets k \< \< \\ % set the key
   %
 % \pcln  \VC{\keyt_{\sss 2}}, \VC{\state} \gets \update(\VC{\state}, \tmp_{\sss\VM{\counter}})\\ % client-- 1st update
 %
  \pcln (p,b) \gets \mathsf{Dec}_{\sss\VC{\keyt_{\sss 2}}}(\ddot M, \ddot t) \< \< \\% client-- decrypt
  %
  \pcln \iif b\neq 1,    \text{\ go\ to\ } \ref{auth:fail} \\ % client-- verify tag
  %
  \pcln \text{Parse\ } p \text{\ yielding\ } \VM{\nonce}, \VM{\trans}  \< \< \\ % client parse
 %
 \pcln \text{Display \VM{\trans} for client to check} \< \< \\
 %
 \pcln \text{\iif client rejects \VM{\trans}, \text{\ go\ to\ } \ref{auth:fail}} \< \< \\
 %
  %\pcln \VC{\counter} \gets \VM{\counter} \< \< \\%client-- set counter
 %
 \pcln \text{Request \VC{\pin} from client} \< \< \\
 %
 \pcln \VC{\verifier} \gets \prf_{\sss\VC{\salt}}(\VC{\pin}) \< \< \\
%
 \pcln  \VC{\keyt_{\sss 3}}, \VC{\state} \gets \update(\VC{\state}, 1) \< \< \\
  %
 \pcln p''=  \VM{\nonce} \|  \VM{\trans} \| \VC{\verifier}\< \< \\ %client--set plaintext
 %
 \pcln \label{auth:gen-res}  \VC{\mathit{response}} \gets \prf_{\sss\VC{\keyt_{\sss 3}}}(p''|| 1) \< \< \\ % client-- encrypt
 %
  \pcln sk^{C} \gets \prf_{\sss\VC{\keyt_{\sss 3}}}(p''|| 2) \< \<  \pclb% client-- encrypt
%  \pcln sk^{C} \gets \hash(\VC{\keyt_{\sss 3}}||p'') \< \< \pclb % client-- encrypt
 %
 \sendmessagerightx[7cm]{6}{ \VC{\mathit{response}}} \\
 %
  \pcln \label{auth:fail} \text{Discard (\VC{\pin}, \VC{\verifier}, \VC{\keyt_{\sss 2}}, \VC{\keyt_{\sss 3}}, \VM{\nonce}, \VM{\trans}}) \\ 
 %%%%% server
 \pcln \< \<\hspace{2.6mm} \VS{\mathit{expected}} \gets \prf_{\sss\VS{\keyt_{\sss3}}}(\VS{\nonce}  \| \VS{\trans} \| \VS{\verifier}||1) \\
 %
 \pcln \< \<\hspace{2.6mm} \iif \VC{\mathit{response}} \ne \VS{\mathit{expected}}, \text{go\ to\ } \ref{auth:fail-server} \\
 %
\pcln\< \<\hspace{2.6mm}  sk^{S} \gets\prf_{\sss\VS{\keyt_{\sss3}}}(\VS{\nonce}  \| \VS{\trans} \| \VS{\verifier}|| 2)\\
 %
 %\pcln \< \<sk^{S} \gets \hash(\VS{\keyt_{\sss 3}}||\VS{\nonce}  \| \VS{\trans} \| \VS{\verifier}) \\
 %
% \pcln \label{auth:fail} \text{Discard \VC{\pin}, \VC{\verifier}, \VC{\keyt_{\sss 2}}, \VC{\keyt_{\sss 3}}, \VM{\nonce}, \VM{\trans}} \\ 
  \pcln \label{auth:fail-server}\< \<\hspace{2.6mm}  \text{Discard (\VS{\keyt_{\sss 2}}, \VS{\nonce}, \VS{\trans}}) 
 }
 %
\end{tcolorbox}
\end{center}
\vspace{-3.4mm}
    \caption{Authentication phase.}
    \label{fig:auth}
\end{figure}
%%%%%%%%%%%%%%%%%%

This phase works as follows. The server first updates the FS-PRG's state and corresponding counter, which results in a new state \VS{\state}, a new random value  \VS{\keyt_{\sss 2}}, and a new temporary counter $\tmp_{\VS{\counter}}$. The server updates the state and the counter one more time which yields a new state \VS{\state}, a new random value \VS{\keyt_{\sss 3}}, and a new counter \VS{\counter}. The server generates a random challenge and two ciphertexts, $\ddot M$ and $\hat M$. The former ciphertext consists of the random challenge and the description of the transaction, encrypted under key \VS{\keyt_{\sss 2}}. The latter ciphertext contains the counter $\tmp_{\VS{\counter}}$, encrypted under key $\VC{k}$. The reason $\tmp_{\VS{\counter}}$ is encrypted under key $\VC{k}$ is to allow the device to decrypt the ciphertext easily 
in case of previous message loss; for instance, when the server sends $(\ddot M, \hat M)$ to the server, but they are lost in transit, multiple times, and a fresh pair finally arrives the client after the server sends them upon the client's request. Encrypting $\tmp_{\VS{\counter}}$ under key $\VC{k}$ (instead of one of the evolving keys) lets the device deal with such a situation. 




Upon receiving the ciphertexts, the device validates and decrypts the messages. It extracts the challenge \VM{\nonce}, counter $\tmp_{\VS{\counter}}$, and transaction \VM{\trans}. It ensures that its own counter is behind the received counter. As will be discussed in \prettyref{sec:synchronisation}, this check should always succeed. The device synchronises its state and counter using the server's messages. Next, the device displays the transaction for the client to check. If the client does not accept the transaction (e.g., due to an attempted man-in-the-browser attack), then the protocol aborts immediately. Assuming the client is willing to proceed, then the device prompts for the PIN, and computes the verifier \VC{\verifier} using the key \VC{\salt}. If the client enters the correct PIN, the verifier will be the same as the one sent to the server during the enrolment phase.



For the device to generate the response message, first it updates its state one more time, which results in a pseudorandom value \VC{\keyt_{\sss 3}}. Then, it derives a pseudorandom value, \VC{\mathit{response}}, from a combination of the random challenge \VM{\nonce}, transaction \VM{\trans}, verifier \VC{\verifier}, and $x=1$  using $\prf$ and \VC{\keyt_{\sss 3}}. The device generates a session key, using the above combination and key with a difference that now $x=2$. The response message is sent to the server. The device discards the PIN, the verifier, all FS-PRG keys, the challenge, and the transaction's description, so as to protect the PIN from discovery. The server computes the expected response message based on its own values of the challenge, transaction, and verifier. Note that the verifier is retrieved from the value set during the enrolment phase. The server then compares the expected response with the response sent by the client. Only if these match, the authentication is considered to have succeeded. If the response does not match the one the server expects this could indicate that the message was tampered with, or that the client entered an incorrect PIN. Next, the server generates the session key the same way as the device does.  The server also discards the FS-PRG key, the challenge, and the transaction's description.

In Appendix \ref{sec::Straw-man-Solutions}, we present a couple of straw-man solutions (that one might be tempted to use to achieve the same goals that our protocol attains) and explain why they would not work.\todo{Either include them or remove this}
%
Below, we formally state the security of our protocol.  First, we present a theorem stating that the advantage of an adversary in breaking the semantic security of the above protocol is negligible.  
\begin{theorem}[Semantic Security]
%Let PIN be an element distributed uniformly at random over a finite dictionary of size $N$. 
Let $\adv$ be a probabilistic polynomial time (PPT) adversary with less than $q_{\sss s}$ interactions with the parties and $q_{\sss p}$ passive eavesdropping, i.e., number of local executions. Let $\lambda$ be a security parameter and $Adv_{\sss\pi}^{\sss ss}(\A)$ be  $\adv$'s advantage (in breaking the semantic security of an AKE scheme $\pi$) as defined in Section \ref{sec::model}. Then, such an advantage for the protocol $\psi$ has the following upper bound:  
%
\vspace{-3mm}
\begin{equation*} 
Adv_{\sss \psi}^{\sss ss}(\A) \leq 2(q_{\sss s}+q_{\sss p})\Big(Adv^{\sss\prf}(\adv)+Adv^{\sss Enc}(\adv)\Big)+\frac{8(2q_{\sss s}+q_{\sss p})}{2^{\sss\lambda}}
\end{equation*}
%
\end{theorem}

Next, we present a theorem stating that the advantage of an adversary in breaking the authentication of the above protocol is negligible.  

\begin{theorem} [Authentication]
Let PIN be an element distributed uniformly at random over a finite dictionary of size $N$. Also, 
let $\adv$ be a PPT adversary with less than $q_s$ interactions with the parties and $q_p$ passive eavesdroppings. Let $\lambda$ be a security parameter and $Adv_{\sss\pi}^{\sss aut}(\A)$ be  $\adv$'s advantage (in breaking the authentication of an AKE scheme $\pi$) as defined in Section \ref{sec::model}. Then, in the protocol $\psi$, $Adv_{\sss \psi}^{\sss aut}(\A)$ has the following upper bound:  
%
\vspace{-3mm}
  \begin{equation*}
 Adv_{\sss \psi}^{\sss aut}(\A)  \leq (q_{\sss s} + q_{\sss p})\Big(Adv^{\sss\prf}(\adv)+Adv^{\sss Enc}(\adv)\Big)+\frac{9q_{\sss s}+4q_{\sss p}}{2^{\sss\lambda}}+  \cfrac{q_{\sss s}}{N}
 \end{equation*}
%
\end{theorem}

\vspace{-2mm}


We refer to Appendix \ref{sec:security} for informal security analysis and Appendix \ref{sec::Formal-Security-Analysis} for formal security proof where the above two theorems will be proven.  


\vspace{-4mm}
\section{System Usability}
\label{sec:asymmetric}

\vspace{-2mm}




Usability is of critical importance for an effective authentication system as otherwise, clients will refuse to use it or implement insecure workarounds \cite{de2013comparative}.
As we highlighted in Section \ref{sec::model}, in our protocol, the server interacts with the device via the client. To accommodate usability and let the device easily receive the server's message, we require the device to be equipped with a scanner/camera, such as the one shown in \prettyref{fig:dp770}. 


\begin{figure}
    \centering
    \includegraphics[width=4cm]{dp770}
    \vspace{-2mm}
    \caption{OneSpan Digipass 770 authentication device.}
    \label{fig:dp770}
\end{figure}


In our protocol, the encrypted messages the server sends are in a form of a QR code, so the client can easily scan them from its computer's screen and transfer them to the device which verifies and decrypts the input messages, as explained in the protocol. However, to avoid limiting the protocol's application, we do not require the client's computer to be equipped with a scanner/camera. Therefore, the client needs to manually insert the message output of the device into its computer.  Once again, to improve usability, it is desirable to reduce the size of each message that the device outputs. {Our protocol allows truncating the verifier, as it is resistant to offline brute-force attacks, with a caveat. Truncating the verifier will create collisions such that for some values of the verifier there will be multiple PINs which are valid. Consequently, an adversary who has stolen a device has a better chance of guessing the PIN than the ideal case where the original message is used and its chance is negligible in the security parameter or the PIN's universe size.} This security-usability trade-off is not specific to our protocol and exists in all hardware token-based multi-factor authentication protocols that do not assume clients' computers are equipped with a scanner and clients have to insert the device's messages into their computer.  


Another consideration is handling mistyped or forgotten PINs. As we highlighted in Section \ref{sec::the-protocol}, the device can ask the client to confirm its PIN by entering the PIN twice; then the device compares the two entries and alters the client if they do not match.  However, it does not check and alert the client whether the PIN is correct.  Such a check has to be carried out on the server-side which comes at a cost of decreased usability.  The protocol presented in this work is useful in its own right; however, it could be considered a basis for a more user-friendly system, tailored to a particular scenario in which it is to be used.




\input{evaluation}

\input{conclusion}



%\section{Acknowledgements}


\bibliographystyle{splncs03}
\bibliography{ref}
\appendix
\input{related-work}
%
\input{forward-PRF-extra}
%
\input{sync}
%
\input{strawman}


\input{informal-sec-analysis}
\input{proof}


\input{evaluation-long}
%\input{strawman}
\end{document}
