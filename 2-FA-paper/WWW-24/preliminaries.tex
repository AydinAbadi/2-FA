%!TEX root = main.tex


\vspace{-2mm}
\section{Notations and Preliminaries}
\vspace{-1mm}
 \subsection{Notations and Assumptions}
  
 To disambiguate the different uses of keys and other items of data, variables are annotated with a superscript to indicate their origin. $\VC{\cdot}$ indicates data stored at the user, $\VS{\cdot}$ means data stored at the server, and $\VM{\cdot}$ indicates data item has been extracted from a message. We define a function $\mathtt{Discard}(.)$ that takes an array of inputs and securely deletes them, e.g., from storage, memory, and catch. 
 
 We assume the token is not penetrated by an adversary in the (very short) period when the inputs of $\mathtt{Discard}(.)$ are set and when  $\mathtt{Discard}(.)$ is executed. %We refer readers to \cite{ReardonBC13} for a survey of secure data deletion approaches. 
 %
  We also assume that a user will not use its hardware token after it has been stolen. % (and it will be issued with a replacement with fresh parameters). 
  Table \ref{notation-table} in Appendix \ref{notation-table-} presents a summary of notations used in this paper. 
 

 
 
% 
% 
% \begin{itemize}
% 
% \item $\prf_{k}(.)$:  Pseudorandom function taking a  key $k$. It is used to derive a verifier and session key
% 
% \item FS-PRG:  Forward-secure Pseudorandom Bit Generator. It is used to derive temporary keys.
% 
% \item $\VC{k}$ and $\VS{k}$: Authenticated Encryption (AE) key at the user and server sides respectively.  Key $k$ is randomly generated by the system operator and stored by the user as $\VC{k}$ and server as $\VS{k}$ at token creation. They are constant for the lifetime of the token.
% 
% \item $\VC{\state}$ and $\VS{\state}$: The state of FS-PRG at the user and server sides respectively. They are initialised to randomly generated state $\state_{\sss 0}$ at token creation. They are updated by using FS-PRG.
% 
% 
% \item $\VC{\keyt_{\sss 1}}$ and  $\VS{\keyt_{\sss 1}}$:  Temporary keys for the enrolment phase. They are output by FS-PRG and used for a single message exchange before being discarded.
% 
% \end{itemize}
 
 
 %We present a summary of variables in \prettyref{tab:variables}. 
 
 %\input{notation-Table}

\subsection{Pseudorandom Function}\label{subsec:PRF}

Informally, a pseudorandom function (\prf) is a deterministic function that takes as input a key and some argument. It outputs a value indistinguishable from that of a truly random function with the same domain and range.  A formal definition of a $\prf$ is given by Katz and Lindell~\cite{KatzLindell2014} and is included in Appendix \prettyref{app:def-FS-PRG}.


 \vspace{-2mm}
\subsection{Forward-Secure Pseudorandom Bit Generator}
 %
A Forward-Secure Pseudorandom Bit Generator (FS-PRG) is a stateful object with two algorithms and two positive integers; namely, $\mathsf{FS\text{-}PRG} = \Big((\mathsf{FS\text{-}PRG}.\kgen, $ $ \mathsf{FS\text{-}PRG.next}),( b, n)\Big)$, as defined in \cite{BellareY03}.  The probabilistic key generation algorithm $\mathsf{FS\text{-}PRG}.\kgen$ takes a security parameter as input and outputs an initial state ${st}_{\sss 0}$ of length $s$ bits. $\mathsf{FS\text{-}PRG.next}$ is a key-updating algorithm which, given the current state ${st}_{\sss i-1}$, outputs a pair of a $b$-bit block ${out}_{\sss i}$ and the next state ${st}_{\sss i}$. We can produce a sequence  ${out}_{\sss 1},..., {out}_{\sss n}$  of  $b$-bit output blocks, by first generating a key  ${st}_{\sss 0}\stackrel{\sss \$}\leftarrow\mathsf{FS\text{-}PRG}.\kgen(1^{\sss \lambda})$ and then running $({out}_{\sss i}, st_{\sss i})\leftarrow  \mathsf{FS\text{-}PRG.next} (st_{\sss i-1})$ for all $i, 1\leq i\leq n$. As with a standard pseudorandom bit generator, the output blocks of this generator should be computationally indistinguishable from a random bit
string of the same length. The additional property required from a
FS-PRG is that even when the
adversary learns the state, output blocks generated before the point of
compromise remain computationally indistinguishable from random bits.
This requirement implies that it is computationally infeasible to
recover a previous state from the current state. Appendix \ref{app:def-FS-PRG} restates a formal definition and construction of  FS-PRG. 


Recall, $\mathsf{FS\text{-}PRG.next}$ updates the state of the forward-secure generation by one step; however, our protocol sometimes needs to invoke $\mathsf{FS\text{-}PRG.next}$ multiple times sequentially. Thus, for the sake of simplicity, we define a wrapper algorithm $ \update(\state_{\sss a}, d)$ which wraps  $\mathsf{FS\text{-}PRG.next}$. Algorithm $\update$  as input takes a current state and new parameter $d$ that determines how many times   $\mathsf{FS\text{-}PRG.next}$ must be invoked internally. It invokes  $\mathsf{FS\text{-}PRG.next}$ $d$ times and outputs the pair  $({out}_{\sss b}, \state_{\sss b})$  which are the output of $\mathsf{FS\text{-}PRG.next}$ when it is invoked for $d$-th time, where $ b> a$. 



%For example, a practical instantiation proposed by Bellare and Yee is
%based on AES. $\mathsf{GEN.next}$ computes the next state by AES-CTR mode
%encrypting $x+s$ zero-bits with a starting counter of $0$, under the key
%$\mathsf{St}_{i-1}$. The first $x$ bits of the ciphertext is $\mathsf{Out}_i$, and the next $s$
%bits are $\mathsf{St}_i$. For $x=s=128$ using AES-128, $\mathsf{GEN.next}$ requires two
%computations of the AES encryption under one key for each update to the
%state and meets the security definitions of forward-secure key updating
%for $n < 2^{64}$.

 \vspace{-1mm}
\subsection{Authenticated Encryption (AE)} 

Informally, authenticated encryption $\Pi=(\mathsf{Gen}, \mathsf{Enc}, \mathsf{Dec})$ is an encryption scheme that simultaneously ensures the secrecy and integrity of a message. It can be built via symmetric or asymmetric-key encryptions. In this work, we use authenticated symmetric-key encryption, due to its efficiency. $\mathsf{Gen}$ is a probabilistic key-generating algorithm that takes a security parameter and returns an encryption key $k$. $\mathsf{Enc}$ is a deterministic encryption algorithm that takes the secret key $k$ and a message $m$, it returns a ciphertext $M$ along with the corresponding tag $t$. $\mathsf{Dec}$ is a deterministic algorithm that takes the ciphertext $M$, the tag $t$, and the secret key $k$. It first checks the tag's validity, if it accepts the tag, then it decrypts the message and returns $(m,1)$. Otherwise, it returns $(.,0)$. 


The security of such encryption consists of the notion of secrecy and integrity. The secrecy notion requires that the encryption be secure against Chosen-Ciphertext Attacks, \ie, CCA-secure. The notion of integrity considers existential unforgeability under an adaptive chosen message attack. We refer readers to \cite{KatzLindell2014} for a formal definition of authenticated symmetric-key encryption. 



%\subsection{Authenticated Symmetric-key Encryption} We make use an Authenticated Encryption Scheme with Auxiliary data, such as AES-GCM.
%The encryption function $\enc_\key(\nonce,H,M)$ takes a non-repeating nonce \nonce, header $H$ and Message $M$, encrypts it under key \key{} and produces ciphertext. The recipient can recover $M$ by passing the decryption function \dec(\nonce,H,C) the same nonce and header, and ciphertext $C$, \ie $M = \dec_\key(\nonce,H,\enc_\key(\nonce,H,M))$.
%The header and message may have multiple fields, which are separated with $\|$.
%Since the header and nonce are both required for decryption, they will be included inside the message outside of the ciphertext.
%If any of \nonce, $H$ or $C$ have been tampered with, the authenticated decryption function will return an error.
%For clarity, in descriptions of the protocol we omit the case of a decryption error; should this occur the protocol exchange is immediately aborted.
%We combine decryption with message decoding through the $\extract_\key$ function which validates and decrypts a message using key \key{} and extracts fields from the plaintext. 

